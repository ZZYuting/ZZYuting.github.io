---
title: 169第k个排列
layout: post
categories: 回溯
excerpt: 
Tags: leetcode
---

给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。

按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：

"123"
"132"
"213"
"231"
"312"
"321"
给定 n 和 k，返回第 k 个排列。

说明：

给定 n 的范围是 [1, 9]。
给定 k 的范围是[1,  n!]。

**示例 1:**

```
输入: n = 3, k = 3
输出: "213"
输入: n = 4, k = 9
输出: "2314"
```

```c++
//方法1，列出全排列，转换为字符串，会超时
class Solution {
public:
    string getPermutation(int n, int k) {
        string result(n,0);
        vector<int> nums;
        for(int i=1;i<=n;i++){
            nums.push_back(i);
        }
        vector<vector<int>> tmp;
        vector<int> sub;
        helper(nums,tmp,sub);
        k--;
        for(int i=0;i<n;i++){
            result[i]=tmp[k][i]+'0';
        }
        return result;
    }
private:
    void helper(vector<int>& nums, vector<vector<int>>& tmp, vector<int>& sub){
        if(sub.size()==nums.size()){
            tmp.push_back(sub);
        }else{
            for(int i=0;i<nums.size();i++){
                if(find(sub.begin(),sub.end(),nums[i])==sub.end()){
                    sub.push_back(nums[i]);
                    helper(nums,tmp,sub);
                    sub.pop_back();
                }
            }
        }
    }
};

//方法2，利用数学方法
//https://www.youtube.com/watch?v=xdvPD1IiyUM
//https://www.youtube.com/watch?v=fe_DMBoe18o
class Solution {
public:
    string getPermutation(int n, int k) {
        string res(n,0);
        vector<int> nums;
        for(int i=1;i<=n;i++){
            nums.push_back(i);
        }
        vector<int> fract(n,1);
        for(int i=1;i<n;i++){
            fract[i]=fract[i-1]*i;
        }
        k--;
        for(int i=0;i<n;i++){
            int index = k/fract[n-1-i];
            res[i]=nums[index]+'0';
            k = k%fract[n-1-i];
            nums.erase(nums.begin()+index);
        }
        return res;
    }
};
```

