---
title: 面试题实现离散随机数发生器
layout: post
categories: 面试题
excerpt: 
Tags: 面试题
---

实现离散分布随机数发生器。提示：可以利用系统的[0,1)均匀随机数发生器。

例子：给定样本0 1 2 出现的概率用数组表示是[0.5, 0.3, 0.2] ，调用10次之后0 1 2出现的次数接近 5 3 2。推广到N种样本（例如0..100万）之后，假设多次调用概率分布不变，怎么实现比较快的采样？



```
方法1:我要的概率是55%，20%,20%，5% {0，1，2，3}
生成0-1之间的数num

0  ... 0.55 ...  0.55+0.2 .... 0.55+0.2+0.2 ... .... 1
num<=0.55 则生成 0
0.55<num<=0.55+0.2 则生成 1
0.75<num<=0.55+0.2 则生成 2
0.95<num<=1 则生成 3

  0。         1             2              3
0......5.5亿......5.5亿+2亿......5.5+2+2亿......10亿

算法，因为计算机中的随机数，按理论上讲都是同概率的伪随机数，因此，每个数被选中的概率是一样的，
因此我们可以设定一个基数，这个基数为10亿，也就是说，概率可以控制到10亿分之一，
因此a数组中0出现的概率为 5亿次（针对10亿来说），也就是50%的概率，
出现1和2的概率都为2亿次，因此也就是20%的概率
出现3的次数为1亿次，因此也就是10%的概率

当你要设计10亿分之1概率时，只要调整一下，后面的权值为1就可以了，如：
int[,2] a = {{0,5.5亿},{1,2亿},{2, 2亿},{3,0.5亿}};
那么出现4的概率就是为10亿分之1




因此，随机一个0到10亿的数。
如果这个数是小于5.5亿，则表示0被选中，
否则，这个权值累加起来存到sum中
然后第二次循环的时候，再判断这个数是否是小于Sum(此时的sum=5.5亿+2亿)，如果小于，说明1被选中，
以此类推
。。。。。。

该算法建立在，伪随机的理论之上（任何数出现的概率都是一样）
```

```c++
#include <iostream>
#include <vector>
using namespace std;

class Solution{
public:
    int Myrandom(vector<vector<float>>& nums, int N){
        int n = 999;
        int size = nums.size();
        float random = rand() % (n + 1) / (float)(n + 1);
        int r = random * N;
        for(int i = 0; i<nums.size(); ++i){
            nums[i][1] = N * nums[i][1];
        }
        int sum = 0;
        for(int i = 0; i<nums.size(); ++i){
            sum += nums[i][1];
            if(r <= sum){
                return nums[i][0];
            }
        }
        return -1;
    }
};
int main(){
    int N = 100000;
    int n = 0;
    cin >> n;
    vector<float> tmp(2,0);
    vector<vector<float>> nums(n,tmp);
    for(int i = 0; i<nums.size(); ++i) {
        cin >> nums[i][0] >> nums[i][1];
    }

    int res = Solution().Myrandom(nums, N);
    cout << res << endl;
    return 0;
}
```



