---
title: 272阶乘后的零
layout: post
categories: 数学
excerpt: 
Tags: 数学
---

给定一个整数 n，返回 n! 结果尾数中零的数量。

示例 1:

输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
示例 2:

输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
说明: 你算法的时间复杂度应为 O(log n) 。

```c++
/*
https://leetcode-cn.com/problems/factorial-trailing-zeroes/solution/c-shu-xue-xiang-xi-tui-dao-by-zeroac/

    求n!
    0的来源 2 * 5 所以一对2和5即可产生一个0,所以0的个数即为min(阶乘中5的个数和2的个数) 
    又因为是2的倍数的数一定比是5的倍数的数多 所以2的个数一定>=5的个数 所以只需要统计 5 的个数了
    例如 5！ = 1 * 2 * 3 * 4 * 5
                  2      2 2  5    一个2和一个5配对出现0 所以5!末尾只有一个零
        而在 n = 25 时 可以产生5的有 5 10 15 20 25 
                                    即 n/5 = 5个 然鹅 25 = 5*5 所以少算了一个5 
        n>=25时,故而需要补上它 因此所有可以产生25的也要加上 
                                    即为 n/5 + n/25  然鹅 125 = 5*25 所以又少算了一个5
        n>=125时,故而需要补上它 因此所有可以产生125的也要加上
                                    即为 n/5 + n/25 + n/125  然鹅 625 = 5*125 所以又少算了一个5
        继续补上...
        所以最终为 n/5 + n/25 + n/125 + n/625 + ... 
                即 n/5 + n/5/5 + n/5/5/5 + n/5/5/5/5 + ... 
        代码如下
推广:求n!中因子p的个数
所以含有一个p的有n/p
所以含有2个p的有n/p2
res += n/p + n/p2 +.... 

*/
class Solution {
public:
    int trailingZeroes(int n) {
        int count = 0;
        while(n>0){
            count += n/5;
            n = n/5;
        }
        return count;
    }
};
```

