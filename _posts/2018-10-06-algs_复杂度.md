---
title: 时间复杂度和空间复杂度
layout: post
categories: Algorithm
excerpt: 
tags: Algorithm
---

时间复杂度和空间复杂度



[TOC]

# 1. 时间复杂度和空间复杂度

## 1.1 基础概念

**（1）算法的时间复杂度反映了程序执行时间随输入规模增长而增长的量级，在很大程度上能很好反映出算法的优劣与否。**

常见的时间复杂度有：常数阶$O(1)$,对数阶$O(log_2n)$,线性阶$O(n)$,线性对数阶$O(nlog_2n)$,平方阶$O(n^2)$，立方阶$O(n^3)$,...k次方阶$O(n^k)$,指数阶$O(2n)$。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。

常见的算法时间复杂度由小到大依次为:
$$
O(1)<O(log_2 n)<O(nlog_2 n)<O(n^2)<O(n^3)<...<O(2^n)<O(n!)
$$

![image](https://ws3.sinaimg.cn/large/006tNbRwly1fvyljroib7j30gc06kt99.jpg)

从图1中可见，我们应该尽可能选用多项式阶$O(n^k)$的算法，而不希望用指数阶的算法。

算法中语句执行次数为一个**常数**，则时间复杂度为**O(1)**,一般来说,只要算法中不存在循环语句，其时间复杂度就是Ο(1)。其中$O(log_2n)$、Ο(n)、 $O(nlog_2 n)$、$O(n^2)$和$O(n^3)$**称为多项式时间，**而Ο(2n)和Ο(n!)称为指数时间。**计算机科学家普遍认为前者（即多项式时间复杂度的算法）是有效算法，把这类问题称为P（Polynomial,多项式）类问题，而把后者（即指数时间复杂度的算法）称为NP（Non-Deterministic Polynomial, 非确定多项式）问题。**

**（2）一个算法的空间复杂度(Space Complexity)S(n)定义为该算法所耗费的存储空间。**

当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为**O(1)**。当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为$O(log_2n)$；当一个算法的空间复杂度与n成线性比例关系时，可表示为**O(n)**。若形参为数组，则只需要为它分配一个存储由实参传送来的一个地址指针的空间，即一个机器字长空间；若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便由系统自动引用实参变量。

**用固定的空间是O(1)**
**和长度相关的是O(n)**
**和树扯上关系可能会是O(logn)**

## **1.2 求解算法的时间复杂度：**

⑴ 找出算法中的基本语句；

　　算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。

⑵ 计算基本语句的执行次数的数量级；

　　只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。

⑶ 用大Ο记号表示算法的时间性能。

　　将基本语句执行次数的数量级放入大Ο记号中。

example：

```c
for (i=1; i<=n; i++)
　　       x++;
for (i=1; i<=n; i++)
　   for (j=1; j<=n; j++)
　　       x++;
```

第一个for循环的时间复杂度为Ο(n)，第二个for循环的时间复杂度为$O(n^2)$，则整个算法的时间复杂度为$O(n+n^2)$。

**在计算算法时间复杂度时有以下几个简单的程序分析法则:**

(1).对于一些简单的输入输出语句或赋值语句,近似认为需要**O(1)**时间

(2).对于**顺序结构**,需要依次执行一系列语句所用的时间可采用大O下"**求和法则**"

**求和法则**:是指若算法的2个部分时间复杂度分别为 **T1(n)=O(f(n))**和 **T2(n)=O(g(n))**,则 **T1(n)+T2(n)=O(max(f(n), g(n)))**

特别地,若T1(m)=O(f(m)), T2(n)=O(g(n)),则 T1(m)+T2(n)=O(f(m) + g(n))

(3).对于**选择结构**,如if语句,它的主要时间耗费是在执行then字句或else字句所用的时间,需注意的是检验条件也需要**O(1)**时间

(4).对于**循环结构**,循环语句的运行时间主要体现在多次迭代中执行循环体以及检验循环条件的时间耗费,一般可用大O下"**乘法法则**"

**乘法法则**: 是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1\*T2=O(f(n)\*g(n))

(5).对于复杂的算法,可以将它分成几个容易估算的部分,然后利用求和法则和乘法法则技术整个算法的时间复杂度

另外还有以下2个运算法则:(1) **若g(n)=O(f(n)),则O(f(n))+ O(g(n))= O(f(n))**；(2) **O(Cf(n)) = O(f(n))**,其中C是一个正常数

## 1.3 Example

**(1)、O(1)**

```c
 Temp=i; i=j; j=temp;   
```

以上三条单个语句的频度均为1，该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作T(n)=O(1)。

**注意：如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。**

**(2)、$O(n^2)$**

```C
     sum=0；                （一次）
     for(i=1;i<=n;i++)     
        for(j=1;j<=n;j++) 
         sum++；            （n2次）
```

解：因为$Θ(n^2+1)=n^2$（Θ即：去低阶项，去掉常数项，去掉高阶项的常参得到），所以$T(n)=O(n^2)$

(3)、

```c
for (i=1;i<n;i++)
    { 
        y=y+1;         （1）  
        for (j=0;j<=(2*n);j++)    
           x++;        （2）      
    }     
```

1的频度是n-1,2的频度是$(n-1)*(2n+1)=2n^2-n-1$,$f(n)=2n^2-n-1+(n-1)=2n^2-2$,

$Θ(2n^2-2)=n^2$

一般情况下，对步进循环语句只需考虑循环体中语句的执行次数，**忽略该语句中步长加1、终值判别、控制转移等成分**，**当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的。**     

(4)、$O(log_2 n)$

```c
i=1;(1)
while(i<=n)
     i=i*2;(2)
```

(1)的频度是1，设语句(2)的频度是f(n),

$2^{f(n)}=n$

$f(n)=log_2n$

$T(n)=O(log_2 n)$

(5)、$O(n^3)$

```c
 for(i=0;i<n;i++)
    {  
       for(j=0;j<i;j++)  
       {
          for(k=0;k<j;k++)
             x=x+2;  
       }
    }
```

最内层循环：

$0+1+...+(i-1)=i(i-1)/2$

i从0-n-1，$O(0+(1-1)*1/2+...+(n)(n-1)/2=n(n+1)(n-1)/6)=O(n^3)$

